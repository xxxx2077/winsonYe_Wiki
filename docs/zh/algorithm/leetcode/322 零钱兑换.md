# 零钱兑换

=== "二维数组dp"

    完全背包问题的应用，物品对应硬币，容量对应整数amount，硬币数量无限，所以为完全背包

    唯一需要注意的是，本题中，因为总金额由硬币凑成，所以容量`j - coins[i]`最后一定要等于0

    在初始化过程中，我们把每个值设为INT_MAX,如果遍历过程，发现使用的`dp[i][j - coins[i]] == INT_MAX`，说明`j - coins[i]`最后不能恰好等于0，所以需要跳过

    如果结果为INT_MAX,那么表示没有任何一种硬币组合能组成总金额，返回 -1 。

    ```C++
    class Solution {
    public:
        int coinChange(vector<int>& coins, int amount) {
            int n = coins.size();
            vector<vector<int>> dp(n, vector<int>(amount + 1, INT_MAX));
            for(int i = 0; i < n; i++)
                dp[i][0] = 0;
            for(int j = 0; j <= amount; j++){
                if(j >= coins[0] && dp[0][j - coins[0]] != INT_MAX )
                    dp[0][j] = dp[0][j - coins[0]] + 1;
            } 
            for(int i = 1; i < n; i++){
                for(int j = 1; j <= amount; j++){
                    if(j >= coins[i] && dp[i][j - coins[i]] != INT_MAX){
                        dp[i][j] = min(dp[i - 1][j], dp[i][j - coins[i]] + 1);
                    }else{
                        dp[i][j] = dp[i - 1][j];
                    }
                }
            }
            return dp[n - 1][amount] == INT_MAX ? -1 : dp[n - 1][amount];
        }
    };
    ```

=== "一维数组dp（优化）"

    ```C++
    class Solution {
    public:
        int coinChange(vector<int>& coins, int amount) {
            int n = coins.size();
            vector<int> dp(amount + 1, INT_MAX);
            dp[0] = 0;
            for (int j = 0; j <= amount; j++) {
                if (j >= coins[0] && dp[j - coins[0]] != INT_MAX)
                    dp[j] = dp[j - coins[0]] + 1;
            }
            for (int i = 1; i < n; i++) {
                for (int j = 0; j <= amount; j++) {
                    if (j >= coins[i] && dp[j - coins[i]] != INT_MAX) {
                        dp[j] = min(dp[j], dp[j - coins[i]] + 1);
                    }
                }
            }
            return dp[amount] == INT_MAX ? -1 : dp[amount];
        }
    };
    ```

    最终可以优化为：
    
    ```C++
    class Solution {
    public:
        int coinChange(vector<int>& coins, int amount) {
            int n = coins.size();
            vector<int> dp(amount + 1, INT_MAX);
            dp[0] = 0;
            for (int j = coins[0]; j <= amount; j++) {
                if (dp[j - coins[0]] != INT_MAX)
                    dp[j] = dp[j - coins[0]] + 1;
            }
            for (int i = 1; i < n; i++) {
                for (int j = coins[i]; j <= amount; j++) {
                    if (dp[j - coins[i]] != INT_MAX) {
                        dp[j] = min(dp[j], dp[j - coins[i]] + 1);
                    }
                }
            }
            return dp[amount] == INT_MAX ? -1 : dp[amount];
        }
    };
    ```