# 139 单词拆分

爬楼梯模型：从s.size()往后倒，判断每个word是否符合

!!! tip "本题思路争议"

    代码随想录里面说这道题属于完全背包问题，因为是求排列数，所以遍历顺序必须先容量再物品，有道理但是不好理解。

    我觉得可以这样归类：

    - 完全背包问题解决组合问题
    - 爬楼梯模型解决排列问题

    本题就是排列问题，因此使用爬楼梯模型

`dp[i]`表示长度为i的字符串能否用单词表示

初始化：

- `dp[0]`表示长度为0的字符串能否用单词表示，题目要求len >= 1，因此len == 0无意义，我们初始化为true方便后面的判断
- 其余的`dp[i]`初始化为false

```C++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for(int j = 1; j <= s.size(); j++){
            for(const string& word: wordDict){
                if(j >= word.size() && s.substr(j - word.size(), word.size()) == word)
                    dp[j] = dp[j] || dp[j - word.size()];
            }
        }
        return dp[s.size()];
    }
};
```

可以进一步优化，比如说：

- 剪枝：当`dp[j]`为true，表示已经有单词满足条件了，后面的单词也就无需遍历了
- word也可以用索引i表示等等

```C++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for(int j = 1; j <= s.size(); j++){
            for(const string& word: wordDict){
                if(j >= word.size() && s.substr(j - word.size(), word.size()) == word)
                    dp[j] = dp[j] || dp[j - word.size()];
                // 优化：剪枝
                if(dp[j]) break;
            }
        }
        return dp[s.size()];
    }
};
```
