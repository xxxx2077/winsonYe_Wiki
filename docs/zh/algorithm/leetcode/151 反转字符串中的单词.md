# 151 反转字符串中的单词

只要知道先把整个字符串反转，每个单词再分别反转，那么这道题就做出来80%了

如果没有要求自己实现反转操作，那么可以直接使用reverse

=== "使用reverse函数""

    ```C++
    class Solution {
    public:
        string preprocess(string s){
            ...
        }

        string reverseWords(string s) {
            string str = preprocess(s);
            cout << str << endl;
            reverse(str.begin(), str.end());
            str.push_back(' ');
            for(int start = 0, end = 0; end < str.size(); end++){
                if(str[end] == ' '){
                    reverse(str.begin() + start, str.begin() + end);
                    start = end + 1;
                    end = start;
                }
            }
            str.pop_back();
            return str;
        }
    };
    ```

=== "自己实现反转"

    ```C++
    class Solution {
    public:
        // 去除前后空格以及单词间的多个空格
        string preprocess(string s){
            ...
        }

        void reverseStr(string& s, int start, int end){
            int left = start, right = end - 1;
            while(left < right){
                swap(s[left], s[right]);
                left++;
                right--;
            }
        }
        string reverseWords(string s) {
            string str = preprocess(s);
            reverseStr(str,0, str.size());
            str.push_back(' ');
            for(int start = 0, end = 0; end < str.size(); end++){
                if(str[end] == ' '){
                    reverseStr(str, start, end);
                    start = end + 1;
                    end = start;
                }
            }
            str.pop_back();
            return str;
        }
    };
    ```

## preprocess函数

难点在于如何处理字符串（不借助语法糖）

字符串的相关处理问题，我放到了[字符串处理](../algorithm_summary/string.md)

=== "我自己的写法"

    这估计是最直接粗暴的，但是充分理解了双指针和去除重复元素的思想

    ```C++
    string preprocess(string s){
        int left = 0, right = s.size() - 1;
        while(s[left] == ' '){
            left++;
        }
        while(s[right] == ' '){
            right--;
        }
        int slow = left, fast = left;
        while(fast <= right){
            if(s[fast] != ' '){
                s[slow] = s[fast];
                slow++;
                fast++;
            }else{
                // 保留一个重复元素
                s[slow] = s[fast];
                slow++;
                // 跳过剩余重复元素
                while(fast <= right && s[fast] == ' ') fast++;
            }
        }
        return s.substr(left, slow - left);
    }
    ```

=== "
