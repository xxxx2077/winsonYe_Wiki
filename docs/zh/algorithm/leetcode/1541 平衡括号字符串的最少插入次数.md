# 1541 平衡括号字符串的最少插入次数

!!! abstract

    来自专题：[括号类问题](https://labuladong.online/algo/problem-set/parentheses/)

```cpp
class Solution {
public:
    int minInsertions(string s) {
        int res = 0;
        int need = 0;
        for(char c : s){
            if(c == '('){
                need += 2;
                if(need % 2 == 1){
                    res++;
                    need--;
                }
            }else{
                if(c == ')'){
                    need--;
                    if(need == -1){
                        res++;
                        need = 1;
                    }
                }
            }
        }
        return res + need;
    }
};
```

## 基本思路

按照[921. 使括号有效的最小添加](https://labuladong.online/algo/problem-set/parentheses/#_921-%E4%BD%BF%E6%8B%AC%E5%8F%B7%E6%9C%89%E6%95%88%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%BB%E5%8A%A0)的思路：

`res`表示需要插入的括号数

`need`表示对于右括号的需求数：

- 左括号需要两个右括号：`need += 2`
- 遇到右括号：`need--`

可以写出以下代码：

```cpp
class Solution {
public:
    int minInsertions(string s) {
        int res = 0;
        int need = 0;
        for(char c : s){
            if(c == '('){
                need += 2;
            }else{
                if(c == ')'){
                    need--;
                }
            }
        }
        return res + need;
    }
};
```

## 关键思路

### **区分`res`和`need`的作用**

`need`虽然是“右括号的需求数”，但是题目限制了**左括号必须对应两个连续的右括号**，`need`只能说明我们需要多少个右括号，而`res`记录的是实际我们需要插入的括号数，无论需要插入的是左括号还是右括号，`res`记录的都是**有效**的括号。

!!! example "举个例子"

    字符串为`“()()))"`，通过分析能够得到：need = 0，但是最终结果res = 3。这是因为第一个左括号没有拥有两个连续的右括号；而在`need`视角，它才不管连续与否，它只注意数量匹配

### 什么时候插入括号

既然`res`表示插入的数量，那么我们什么时候需要插入：

**”什么时候插入左括号"**：当**只有右括号**的时候（其他括号匹配已抵消）。这时候`need = -1`，我们操作为`res++; need = 1`

该判断在**遇到右括号**时候执行

```cpp
if(need == -1){
    res++;
    need = 1;
}
```

!!! tip "为什么`need = 1`"

    加入一个左括号，需要两个右括号，`need = -1`时已经有一个右括号，因此只需要一个右括号

**“什么时候插入右括号”**: 

首先我们不要忘记右括号必须是连续的，因此一个左括号与下一个左括号之间，必须拥有两个连续的右括号（其他匹配的括号抵消）； 

**因此什么时候插入右括号，当我们到达下一个左括号，发现右括号数量不为偶数（奇数）的时候。**

该判断在**遇到左括号**的时候执行

```cpp
if(need % 2 == 1){
    res++;
    need--;
}
```

!!! tip "为什么`need--`"

    因为右括号数量为奇数，我们加入一个右括号，使其变为偶数，因此`need--`

!!! tip "为什么`return res + need`"

    从以上思路可以知道，我们遍历到左括号处理的是「上一个左括号的问题（右括号为奇数）」，遍历到右括号处理的是「只有右括号的问题」

    那么遍历到最后一个左括号以及之后的元素，我们如何处理右括号，答案是通过右括号需求数`need`。因为已经是最后一个左括号，遍历结束时，`need`对应的就是我们需要插入的右括号数