# 19 删除链表的第N个节点

> 可参考
> https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html#%E6%80%9D%E8%B7%AF

为什么需要移动n + 1步

- 题目要求的是倒数第n个节点
- 我们假设fast刚好位于末尾元素的下一个位置，值为nullptr
- 为了方便删除倒数第n个节点，slow需要位于倒数第n + 1位置
- 因此slow与fast位置分别为第n + 1个元素和第0个元素（从右往左数），fast需要移动n + 1次

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyNode = new ListNode(-1, head);
        ListNode *fast = dummyNode, *slow = dummyNode;
        // fast需要移动n + 1步，以保证slow刚好在倒数第n个节点的前一个节点
        for (int i = 1; i <= n + 1 && fast; i++) {
            fast = fast->next;
        }
        while (fast) {
            fast = fast->next;
            slow = slow->next;
        }

        ListNode* tmp = slow->next;
        slow->next = slow->next->next;
        delete tmp;

        ListNode* newHead = dummyNode->next;
        delete dummyNode;
        return newHead;
    }
};
```

- 时间复杂度: O(n)
- 空间复杂度: O(1)


