# 求最大公约数（Greatest Common Divisor）

欧几里得算法

## 算法原理

欧几里得算法（Euclidean algorithm）的正确性基于以下数学原理：

### 定理
两个整数 a 和 b（假设 a > b）的最大公约数等于 b 和 a 除以 b 的余数 r 的最大公约数。用公式表示就是：
\[ \text{gcd}(a, b) = \text{gcd}(b, a \% b) \]

这里 `%` 表示取模运算，即求余数。

### 证明
为了证明这个定理，我们需要说明任何同时是 a 和 b 的公约数也必须是 b 和 \(a \% b\) 的公约数，反之亦然。这样我们就可以得出结论，a 和 b 的最大公约数与 b 和 \(a \% b\) 的最大公约数相同。

#### 假设 d 是 a 和 b 的一个公约数
这意味着 d 同时整除 a 和 b，即：
- \(d | a\)
- \(d | b\)

根据 a 除以 b 的带余除法，我们可以写成：
\[ a = kb + r \]
其中 k 是商，r 是余数（\(r = a \% b\)），并且 \(0 \leq r < b\)。

由于 d 整除 a 和 b，我们可以得到：
\[ a = kd + md \]
\[ b = nd \]
对于某些整数 k 和 n。因此，将 \(a = kb + r\) 改写为：
\[ r = a - kb \]
\[ r = (kd + md) - kn(d) \]
\[ r = (m - kn)d \]

这表明 r 也可以被 d 整除，即 \(d | r\)。

#### 结论
既然任何同时是 a 和 b 的公约数也是 b 和 \(a \% b\) 的公约数，那么 a 和 b 的最大公约数（GCD）必定是 b 和 \(a \% b\) 的公约数之一。同理可以证明，任何同时是 b 和 \(a \% b\) 的公约数也是 a 和 b 的公约数。所以，a 和 b 的最大公约数与 b 和 \(a \% b\) 的最大公约数相等。

通过不断地应用上述过程，直到余数为 0，最后一个非零余数就是原始两个数的最大公约数。这是因为当余数为 0 时，意味着较小的那个数能够完全整除较大的那个数，这时较小的那个数就是两者的最大公约数。

这就是为什么欧几里得算法是正确的，并且能够有效地找到两个整数的最大公约数。

## 算法实现

```go
package main

import "fmt"

func GCD(a int, b int) int {
	// GCD(a, b) == GCD(b, a%b)
	for b != 0 {
		a, b = b, a % b
	}
	return a
}

func main() {
	var a, b int
	fmt.Scanln(&a, &b)
	fmt.Println(GCD(a, b))
}
```

