# 链表

## 虚拟头节点

需要创造新链表时，使用虚拟头节点可以简化边界的处理

相关题目
- 链表合二为一：[合并两个有序链表](../leetcode/21%20合并两个升序链表.md)
- 原链表一分为二：[分隔链表](../leetcode/86)
- 链表合k为一：[合并k个有序链表](../leetcode/23%20合并K个升序链表.md)

## 链表拼接

原链表的节点接到新链表上，而不是 new 新节点来组成新链表的话，需要注意两个操作：

1. 断开节点和原链表之间的链接。但凡遇到这种情况，就把原链表的节点断开，这样就不会出错了。

    例如：

    ```C++
    ListNode* tmp = head->next;
    head->next = nullptr;
    ```

2. 原链表继续遍历

    例如：
    ```C++
    p1->next = head;
    p1 = p1->next; //这一步不能漏掉
    ```

**举个例子**

[86 分隔链表](../leetcode/86%20分隔链表.md)

## 双指针

利用双指针之间的距离，实现一次遍历获得链表的不同位置

通常开始时，p1与p2之间相距k，k为目的位置，

之后，p1和p2同时移动

结束时，p1指向链表末尾，p2为目的位置

### 求链表倒数第k个节点

**求倒数第k个节点：因为p1指向链表末尾，所以p2和p1相距k**

首先，我们先让一个指针 p1 指向链表的头节点 head，然后走 k 步

![picture 0](https://labuladong.online/algo/images/linked-list-two-pointer/1.jpeg)

现在的 p1，只要再走 n - k 步，就能走到链表末尾的空指针了对吧？

趁这个时候，再用一个指针 p2 指向链表头节点 head：

![picture 1](https://labuladong.online/algo/images/linked-list-two-pointer/2.jpeg)

接下来就很显然了，让 p1 和 p2 同时向前走，p1 走到链表末尾的空指针时前进了 n - k 步，p2 也从 head 开始前进了 n - k 步，停留在第 n - k + 1 个节点上，即恰好停链表的倒数第 k 个节点上：

![picture 2](https://labuladong.online/algo/images/linked-list-two-pointer/3.jpeg)

相关题目：
- [删除链表的倒数第N个节点](../leetcode/19%20删除链表的第N个节点.md)

### 快慢指针

#### 求链表的中点

求链表中点其实就是求倒数第n/2个节点，但是n我们并不知道，所以不能使用[求链表倒数第k个节点](#求链表倒数第k个节点)

在这种情况下，我们可以使用「快慢指针」

我们让两个指针 slow 和 fast 分别指向链表头结点 head。

每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。

相关题目：
- 

#### 判断链表是否包含环

每当慢指针 slow 前进一步，快指针 fast 就前进两步。

如果 fast 最终能正常走到链表末尾，说明链表中没有环；如果 fast 走着走着竟然和 slow 相遇了，那肯定是 fast 在链表中转圈了，说明链表中含有环。

