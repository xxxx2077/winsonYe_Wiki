# 输入输出

## 输入输出流

[【必读链接】输入输出流](https://blog.csdn.net/qq_44859843/article/details/130928744)

输入流（例如键盘）和输出流（例如屏幕）指代输入输出设备

在C++中，输入流和输出流被抽象为一个对象，封装了对应的IO操作。通过使用IO流对象，可以间接操作对应的IO设备。

例如std::cout作为标准输出流对象，通过`std::cout << num << std:: endl;`可以将变量打印到屏幕上。

### istringstream用法

常见用法：从字符串中提取出一个个有意义的单词（跳过空白部分）

如下例代码：

```cpp
istringstream iss(newStr);
string word;
while (iss >> word) {
    cout << word << endl;
}
```

它的作用是：**将字符串 `newStr` 按空白字符（空格、换行、制表符等）分割成一个个“单词”并逐个输出。**

---

#### ✅ 这一步有什么用？

##### 1. `istringstream iss(newStr);`
- 创建一个 **字符串输入流对象 `iss`**，它将字符串 `newStr` 视为一个输入源。
- 就像你可以从键盘输入读取内容一样，现在可以从这个字符串中读取内容。

##### 2. `string word;`
- 定义一个字符串变量 `word`，用来存储每次从流中提取出的一个“单词”。

##### 3. `while (iss >> word)`
- 使用 **流提取运算符 `>>`** 从 `iss` 中读取数据：
  - 默认情况下，`>>` 会跳过所有**空白字符（空格、tab、换行）**。
  - 然后读取下一个非空白字符序列，直到遇到下一个空白字符为止。
- 所以这个循环的作用是：
  - 把字符串 `newStr` 中的所有**被空白分隔的内容**一个一个地读出来。
  - 每次读出一个“词”，存入 `word`，然后进入循环体处理。

##### 4. `cout << word << endl;`
- 输出每个提取出来的单词。

---

#### 🧠 为什么打印出来的单词不包含空格？

因为：

- **`operator>>`（即 `>> word`）** 是按“空白分隔”的方式来读取内容的。
- 它会自动忽略所有的空白字符（包括多个连续的空格、制表符 `\t`、换行符 `\n` 等），然后读取下一个非空白字符组成的“单词”。
- 因此，**空格本身不会被作为单词的一部分保存下来**。

---

#### 🔍 示例说明

假设你有如下字符串：

```cpp
string newStr = "   Hello   World!     This is C++.";
```

执行以下代码：

```cpp
istringstream iss(newStr);
string word;
while (iss >> word) {
    cout << word << endl;
}
```

#### 输出结果为：

```
Hello
World!
This
is
C++.
```

可以看到：

- 所有的空格都被跳过了。
- 每个“单词”被单独提取出来。
- 即使原始字符串中有多个连续空格，也只当做一个分隔符处理。

---

## 输入API

在 C++ 中，`getline()` 和 `getchar()` 都是用于从输入流中读取数据的函数。

- 如果你需要读取整个行或按特定分隔符分割的多个字符串，使用 `getline()` 更合适。
- 如果你需要逐字符处理输入（例如实现字符级别的交互），那么 `getchar()` 是更好的选择。

### `getline()`

`getline()` 函数主要用于从输入流（如 `std::cin` 或 `std::istringstream`）中读取一行或多段以特定分隔符分隔的字符串。它有两种形式：

#### 形式一：从输入流中读取一行
```cpp
std::istream& getline(std::istream& is, std::string& str);
```
- **参数**：
  - `is`: 输入流对象。
  - `str`: 存储读取内容的目标字符串。
- **行为**：从输入流 `is` 中读取字符直到遇到换行符 `\n`（包括换行符），并将结果存储在 `str` 中。换行符会被提取并丢弃。
- **返回值**：返回输入流对象 `is`。如果到达文件末尾或者发生读取错误，则返回的流对象将处于失效状态。

#### 形式二：使用自定义分隔符读取
```cpp
std::istream& getline(std::istream& is, std::string& str, char delim);
```
- **参数**：
  - `delim`: 自定义的终止字符，默认为换行符 `\n`。
- **行为**：与第一种形式类似，但允许指定一个自定义的分隔符来代替默认的换行符 `\n`。

#### 示例代码：
```cpp
#include <iostream>
#include <string>

int main() {
    std::string line;
    std::cout << "请输入一行文本：" << std::endl;
    std::getline(std::cin, line); // 读取整行输入
    std::cout << "你输入的是：" << line << std::endl;
    return 0;
}
```

### `getchar()`

`getchar()` 是一个标准库函数，用于从标准输入（通常是键盘）读取单个字符，并将其作为 `int` 类型返回（为了能够表示所有可能的字符以及文件结束标记 EOF）。其原型如下：

```cpp
int getchar(void);
```

- **行为**：从标准输入缓冲区读取下一个字符（不包括换行符 `\n`）。如果输入流为空或遇到文件结束符（EOF），则返回 EOF。
- **注意**：`getchar()` 会等待用户输入并按下回车键后才会处理输入，但它不会消耗换行符，换行符仍然留在输入缓冲区中。

#### 示例代码：
```cpp
#include <iostream>

int main() {
    std::cout << "请输入一个字符：" << std::endl;
    int ch = getchar(); // 读取单个字符
    if (ch != EOF) {
        std::cout << "你输入的字符是：" << static_cast<char>(ch) << std::endl;
    }
    return 0;
}
```

!!! info "对char的深入理解"

    我们通常认为`char c = 'A'`中`c`就是一个字符
    
    实则不然，char类型并不直接代表字符。
    
    **char类型本质上是整数类型，存储一个字节（8位）的数值**

    > 在这种层面上看，char和int没什么不同，无非是存储范围的大小，如同int和long

    > 这也应证了计算机那一句老话：**一切信息的本质都是0/1数字**

    **为什么char类型能输出字符？**

    这是因为 **输出** 和 **[编码规则](https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)**

    举个例子

    `char c = 'A'`中，计算机识别到`'A'`为字符字面量，通常查询**编码表（通常为ASCII）**得到'A'对应的数值为65

    计算机将65存储到`c`对应的内存空间中

    **此时`char c = 'A'`等价于`char c = 65`**

    当你输出这个 char 变量时：

    ```cpp
    std::cout << c; // 输出 'A'
    std::cout 看到你输出的是一个 char 类型。
    ```

    输出流接受的参数类型为char，它调用char类型相关的函数，而这方面的函数定义为将数值转换为字符。
    
    **因此表现为，输出流知道应该把这个整数 65 当作一个字符代码来解释。**

    它再次查询编码表，找到 65 对应的字符是 'A'，然后在屏幕上显示 'A'。

    好了，现在我们总结一下，**为什么char能表示字符？**

    这是因为我们规定了编码规则，往char变量写入的每个数值会根据编码表对应一个字符。
    
    我们当然把char变量当作int变量使用。
    
    但是当输出char变量时，输出流会根据char类型执行“转换为字符"的操作，因此char类型能输出字符

    ```cpp
    #include <iostream>
    using namespace std;

    int main(){
        char c = 65;
        c = c + 2;
        cout << char(c) << endl;
    }
    // 输出C
    ```
    以上例子验证了这一点


### 对比 `getline()` 和 `getchar()`

| 特性 | `getline()` | `getchar()` |
|---|---|---|
| 功能 | 读取一行或多段以特定分隔符分隔的字符串 | 读取单个字符 |
| 参数 | 输入流对象、目标字符串、可选分隔符 | 无 |
| 返回值 | 输入流对象 | 读取的字符（作为 `int` 类型返回，以便能表示 EOF） |
| 使用场景 | 当需要处理包含空格在内的整行输入时 | 当只需要逐个字符读取时 |




